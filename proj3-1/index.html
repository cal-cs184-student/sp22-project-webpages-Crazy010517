<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c2{margin-left:-27pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-22.5pt;height:11pt}.c4{margin-left:-27pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-22.5pt}.c1{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c7{color:#000000;text-decoration:none;vertical-align:baseline;font-size:17pt;font-family:"Arial";font-style:normal}.c13{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c12{color:#000000;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c10{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c14{background-color:#ffffff;font-size:10.5pt;color:#1155cc}.c6{color:inherit;text-decoration:inherit}.c8{color:#1c464a;font-size:11.5pt}.c3{color:#0f68a0;font-size:11.5pt}.c9{color:#326d74;font-size:11.5pt}.c5{font-weight:700}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c10"><p class="c4"><span class="c12 c5">Overview</span></p><p class="c4"><span class="c11">In this project, I implemented several functions of the rendering pipeline. We started off with ray generation and ray intersections with the scene. This implementation proved to be quite slow until we implemented our bounding volume hierarchy data structure to accelerate ray intersections by a factor of several hundreds. Then we lit up our scene by implementing direct lighting as well as indirect lighting. Lastly, we implemented adaptive sampling to reduce unnecessary sampling on certain parts of the image. This project helped me gain a deeper understanding of a wide variety of topics from Monte Carlo estimators to triangle/plane intersections to lighting calculations and much more. </span></p><p class="c2"><span class="c5 c7"></span></p><p class="c4"><span class="c12 c5">Part 1</span></p><p class="c2"><span class="c5 c12"></span></p><p class="c4"><span class="c1">Walk through the ray generation and primitive intersection parts of the rendering pipeline.</span></p><p class="c4"><span>We start off with the </span><span class="c8">Camera</span><span class="c3">::generate_ray() </span><span class="c0">function where we transform the image coordinates into camera coordinates (by first calculating the width and height using hFov and vFov and then scaling the given x and y into the camera x and y values). Then we transform the calculated Vector3D(cam_x, cam_y, -1) into world coordinates by multiplying c2w with it and normalizing the vector (this is the direction vector). Lastly, we create the ray and set min_t and max_t.</span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span>Next, we implemented </span><span class="c8">PathTracer</span><span class="c3">::raytrace_pixel() </span><span>where we took num_samples random samples using the ray generation function and </span><span class="c9">gridSampler-&gt;get_sample()</span><span>, averaged the value returned by </span><span class="c3">est_radiance_global_illumination()</span><span class="c0">, and filled in the corresponding pixel in sampleBuffer with the average radiance.</span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span>I used the same method for both </span><span class="c8">Triangle</span><span class="c3">::has_intersection()</span><span>&nbsp;and </span><span class="c8">Triangle</span><span class="c3">::intersect()</span><span>&nbsp;which was the Moller Trumbore algorithm which gives us the t value and the barycentric coordinates. If t is not within the constraints of </span><span class="c9">r.min_t</span><span>&nbsp;and </span><span class="c9">r.max_t</span><span class="c0">, then we return false right away. If t is valid, then we check if alpha, beta, and gamma are all between 0 and 1 (inclusive) and add up to 1, which indicates the point is inside the triangle. We also use these coordinates to calculate the normal.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 287.50px; height: 191.17px;"><img alt="" src="images/image2.png" style="width: 287.50px; height: 191.17px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span class="c0">For sphere intersection, I referenced the slide from lecture and solved the quadratic formula for the variable t (ending up with two t values). We choose the smaller t value that is within the bounds of min_t and max_t as our primary t value. The other t value is assigned to t2 (if it&rsquo;s also within the bounds). To calculate the normal, we plug in our t value into the ray equation to get the intersection point and subtract it from the center of the sphere and normalize the resulting vector. </span></p><p class="c4"><span>&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 344.09px; height: 253.10px;"><img alt="" src="images/image29.png" style="width: 344.09px; height: 253.10px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span class="c1">Explain the triangle intersection algorithm you implemented in your own words.</span></p><p class="c4"><span>As mentioned earlier, we used the Moller Trumbore algorithm shown in lecture which gives us the t value and the barycentric coordinates. It was not fully explained how the algorithm is derived but it is essentially an optimization of many cross product calculations. We first check if t is within the constraints of </span><span class="c9">r.min_t</span><span>&nbsp;and </span><span class="c9">r.max_t</span><span>. If it isn&rsquo;t,</span><span class="c0">&nbsp;then we immediately return false. Otherwise, given the barycentric coordinates, we know that the intersection lies in the triangle if alpha, beta, and gamma are all between 0 and 1 (inclusive) and add up to 1.</span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 287.50px; height: 191.17px;"><img alt="" src="images/image2.png" style="width: 287.50px; height: 191.17px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span class="c1">Show images with normal shading for a few small .dae files.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 297.16px; height: 227.53px;"><img alt="" src="images/image1.png" style="width: 297.16px; height: 227.53px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 294.50px; height: 217.10px;"><img alt="" src="images/image26.png" style="width: 294.50px; height: 217.10px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c0">Balls&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; Coil</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 295.08px; height: 237.86px;"><img alt="" src="images/image40.png" style="width: 295.08px; height: 237.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c0">Gems</span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span class="c1">Part 2</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span class="c1">Walk through your BVH construction algorithm. Explain the heuristic you chose for picking the splitting point.</span></p><p class="c4"><span class="c0">My BVH construction algorithm involves a recursive process where at every step, I split the primitives in the current node into a left and right node with the recursive process terminating when the number of primitives in the current node is less than or equal to max_leaf_size. </span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span class="c0">For the heuristic, I decided to simply split along the longest axis. For the split, I sorted the primitives based on the chosen axis and put the first half of the primitives in the left node and the second half of the primitives in the right node. This process also ensured that there wouldn&rsquo;t be infinite recursion caused by all of the primitives being split into the left or right node.</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span class="c1">Show images with normal shading for a few large .dae files that you can only render with BVH acceleration.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 264.50px; height: 199.65px;"><img alt="" src="images/image9.png" style="width: 264.50px; height: 199.65px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 262.76px; height: 197.07px;"><img alt="" src="images/image6.png" style="width: 262.76px; height: 197.07px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 270.91px; height: 217.07px;"><img alt="" src="images/image42.png" style="width: 270.91px; height: 217.07px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 200.74px; height: 210.14px;"><img alt="" src="images/image11.png" style="width: 200.74px; height: 210.14px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span class="c1">Compare rendering times on a few scenes with moderately complex geometries with and without BVH acceleration. Present your results in a one-paragraph analysis.</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span>bench.dae: </span><span class="c5">150.2</span><span>&nbsp;seconds without BVH, </span><span class="c5">0.075</span><span>&nbsp;seconds with BVH, </span><span class="c5">2002x</span><span class="c0">&nbsp;speedup</span></p><p class="c4"><span>coil.dae: </span><span class="c5">15.4</span><span>&nbsp;seconds without BVH, </span><span class="c5">0.128</span><span>&nbsp;seconds with BVH, </span><span class="c5">120x </span><span class="c0">speedup</span></p><p class="c4"><span>bunny.dae: </span><span class="c5">79.91</span><span>&nbsp;seconds without BVH, </span><span class="c5">0.114</span><span>&nbsp;seconds with BVH, </span><span class="c5">701x </span><span class="c0">speedup</span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span>Based on the testing results, implementing BVH clearly has an immense impact on the speed of intersection tests. With a naive ray intersection implementation, we have to test for intersections with </span><span class="c5">every single </span><span class="c0">primitive in the scene. With BVH acceleration, we only need to test intersections with a few axis-aligned bounding boxes as we traverse down the tree and a small handful of primitives in the leaf bounding boxes that we intersect. The tests above have shown a speedup by a factor of hundreds.</span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span class="c1">Part 3</span></p><p class="c4"><span class="c1">Walk through both implementations of the direct lighting function.</span></p><p class="c4"><span class="c0">Hemisphere direct lighting: for each of the num_sample rays (randomly sampled from the hemisphere), I used the result of the ray intersection to calculate the outgoing light for the ray (original intersection bsdf * the emission of the new intersection&rsquo;s bsdf * cos(w_in) * 2 * &pi;). After accumulating all of the outgoing light at the original hit point, we divide it by the number of samples.</span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span class="c0">Importance direct lighting: Unlike hemisphere direct lighting where we randomly shoot rays into the hemisphere (which is inefficient because many rays don&rsquo;t hit any light sources and it&rsquo;s basically impossible for the ray to randomly hit a point light), importance direct lighting focuses on shooting out rays at the light sources in the scene. For each light in the scene, we take num_samples (1 sample for point lights because all samples are the same, ns_area_light samples for other lights). For each sample, we first discard the ones where the light is behind the surface of the original intersection. Then we accumulate the outgoing light similarly to above and finally divide by ns_area_light at the end of the function.</span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span class="c0">Both of these functions required caution with what space each Vector3D was in as well as using EPS_F to avoid intersecting certain things (such as the original intersection when casting a ray to a light source).</span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span class="c1">Show some images rendered with both implementations of the direct lighting function.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 298.50px; height: 223.00px;"><img alt="" src="images/image17.png" style="width: 298.50px; height: 223.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 223.50px; height: 223.50px;"><img alt="" src="images/image12.png" style="width: 223.50px; height: 223.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 297.50px; height: 223.13px;"><img alt="" src="images/image38.png" style="width: 297.50px; height: 223.13px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 226.50px; height: 226.50px;"><img alt="" src="images/image37.png" style="width: 226.50px; height: 226.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span class="c1">Focus on one particular scene with at least one area light and compare the noise levels in soft shadows when rendering with 1, 4, 16, and 64 light rays (the -l flag) and with 1 sample per pixel (the -s flag) using light sampling, not uniform hemisphere sampling.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 297.50px; height: 222.58px;"><img alt="" src="images/image8.png" style="width: 297.50px; height: 222.58px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 304.50px; height: 227.82px;"><img alt="" src="images/image15.png" style="width: 304.50px; height: 227.82px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c1">l = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; l = 4</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 300.50px; height: 224.01px;"><img alt="" src="images/image4.png" style="width: 300.50px; height: 224.01px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 303.92px; height: 226.72px;"><img alt="" src="images/image36.png" style="width: 303.92px; height: 226.72px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c1">l = 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;l = 64</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span class="c0">As the number of rays increases, the soft shadows get less and less noisy. This is because with a smaller amount of rays, there is a higher chance that none of the rays hit the light source causing a harsh black shadow at that pixel. As the number of rays increases, the shadow color converges to the true brightness.</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span class="c1">Compare the results between uniform hemisphere sampling and lighting sampling in a one-paragraph analysis.</span></p><p class="c4"><span class="c0">Uniform hemisphere sampling has much more noise than lighting sampling when we use the same number of rays. This is due to the nature of hemisphere sampling which randomly shoots out rays resulting in many &ldquo;wasted&rdquo; rays that do not return any useful lighting contribution. Additionally, it is extremely unlikely for a random ray to hit a point light, essentially making point lights meaningless when rendering with uniform hemisphere sampling. Lighting sampling concentrates on directing rays at light sources which ensures that each ray is meaningful (unless the light source is behind the surface or obstructed). </span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span class="c1">Part 4</span></p><p class="c4"><span class="c1">Walk through your implementation of the indirect lighting function.</span></p><p class="c4"><span>My indirect lighting function starts off by calculating one_bounce_radiance. Then it runs the Russian Roulette termination &ldquo;algorithm&rdquo; to determine if the recursion should stop (it is ensured that there will be at least one indirect bounce if indirect illumination is turned on as per the specs). If the recursion is not terminated, then we get a random w_in and pdf from </span><span class="c9">isect.bsdf-&gt;sample_f() </span><span>a</span><span>nd cast a new ray in the direction of w_in. If the ray intersects with an object, then we recursively call </span><span class="c3">at_least_one_bounce_radiance() </span><span>and multiply the result with the original intersection&rsquo;s bsdf * cos(w_in) and divide by (pdf * RR) where RR is the probability of continuing the recursion. This value is finally added to the one_bounce_radiance and returned.</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span class="c1">Show some images rendered with global (direct and indirect) illumination. Use 1024 samples per pixel.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 318.50px; height: 238.88px;"><img alt="" src="images/image5.png" style="width: 318.50px; height: 238.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 311.50px; height: 234.23px;"><img alt="" src="images/image33.png" style="width: 311.50px; height: 234.23px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 312.03px; height: 233.42px;"><img alt="" src="images/image16.png" style="width: 312.03px; height: 233.42px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 316.50px; height: 236.44px;"><img alt="" src="images/image41.png" style="width: 316.50px; height: 236.44px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 498.50px; height: 373.88px;"><img alt="" src="images/image21.png" style="width: 498.50px; height: 373.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span class="c1">Pick one scene and compare rendered views first with only direct illumination, then only indirect illumination. Use 1024 samples per pixel. (You will have to edit PathTracer::at_least_one_bounce_radiance(...) in your code to generate these views.)</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.71px; height: 229.28px;"><img alt="" src="images/image13.png" style="width: 305.71px; height: 229.28px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 303.50px; height: 227.63px;"><img alt="" src="images/image10.png" style="width: 303.50px; height: 227.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c0">The left image shows a rendering with only direct illumination. Parts of the shape that are not directly in line of sight to the light source are not lit up at all. In the second image, all of the light comes from indirect illumination (with the exception of the light source itself). This is most obvious in the top parts of the ball as they are not lit up as they are in the first image. These two renderings show how direct illumination and indirect illumination sum up to create realistic lighting.</span></p><p class="c2"><span class="c1"></span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span class="c1">For CBbunny.dae, compare rendered views with max_ray_depth set to 0, 1, 2, 3, and 100 (the -m flag). Use 1024 samples per pixel.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 319.50px; height: 239.07px;"><img alt="" src="images/image22.png" style="width: 319.50px; height: 239.07px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 317.50px; height: 236.78px;"><img alt="" src="images/image23.png" style="width: 317.50px; height: 236.78px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c1">m = 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = 1</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 309.50px; height: 232.13px;"><img alt="" src="images/image18.png" style="width: 309.50px; height: 232.13px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 308.50px; height: 231.38px;"><img alt="" src="images/image43.png" style="width: 308.50px; height: 231.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c1">m = 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m = 3</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 309.50px; height: 232.13px;"><img alt="" src="images/image31.png" style="width: 309.50px; height: 232.13px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c1">m = 100</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span class="c0">At a max depth = 0, the only thing that is lit up is the light source itself. With a max depth = 1, lighting on other objects only comes directly from the light sources. At a max depth = 2, we see a significant change from a max depth = 1 as the overall image becomes much lighter and the black ceiling as well as parts hidden from the light source is now lit up from the reflected light. At a max depth = 3, the image gets even brighter with the bunny now the red/blue colors bleeding noticeably onto the bunny. At a max depth = 100, the image does not change significantly from m = 3 (most likely due to Russian Roulette terminating rays far before 100 bounces). The red/blue colors are even more noticeable on the bunny and on the walls and the image is overall brighter. </span></p><p class="c2"><span class="c1"></span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span class="c1">Pick one scene and compare rendered views with various sample-per-pixel rates, including at least 1, 2, 4, 8, 16, 64, and 1024. Use 4 light rays.</span></p><p class="c4"><span class="c1">You will probably want to use the instructional machines for the above renders in order to not burn up your own computer for hours. </span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.50px; height: 229.10px;"><img alt="" src="images/image28.png" style="width: 307.50px; height: 229.10px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.50px; height: 229.33px;"><img alt="" src="images/image34.png" style="width: 306.50px; height: 229.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c1">spp = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spp = 2</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 310.50px; height: 232.10px;"><img alt="" src="images/image20.png" style="width: 310.50px; height: 232.10px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 311.50px; height: 232.85px;"><img alt="" src="images/image24.png" style="width: 311.50px; height: 232.85px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c1">spp = 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;spp = 8</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.50px; height: 229.88px;"><img alt="" src="images/image7.png" style="width: 306.50px; height: 229.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 303.50px; height: 227.63px;"><img alt="" src="images/image35.png" style="width: 303.50px; height: 227.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c1">spp = 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;spp = 64</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 376.50px; height: 282.38px;"><img alt="" src="images/image19.png" style="width: 376.50px; height: 282.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c1">spp = 1024</span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span class="c0">With lower samples per pixel, the image gets more and more noisy. As seen in the image with 1 spp, there is so much noise everywhere and the white walls are just filled with random red and blue pixels. The shadows under the bunny are also very harsh. As we increase the number of samples per pixel, the colors start blending nicely and the shadows become softer. </span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span class="c1">Part 5</span></p><p class="c4"><span class="c1">Walk through your implementation of the adaptive sampling.</span></p><p class="c4"><span class="c0">For my implementation of the adaptive sampling, I kept a running sum of radiance.illum() and radiance.illum() squared. At every samplesPerBatch iteration, I plug in the values for the formulas shown below and determine if enough sampling has been done to accurately estimate the pixel color noise free. If enough sampling has been done, I break out of the sampling loop and save the number of samples used to sampleCountBuffer. </span></p><p class="c2"><span class="c0"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 227.50px; height: 94.63px;"><img alt="" src="images/image27.png" style="width: 227.50px; height: 94.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 319.50px; height: 89.86px;"><img alt="" src="images/image3.png" style="width: 319.50px; height: 89.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 379.50px; height: 95.67px;"><img alt="" src="images/image39.png" style="width: 379.50px; height: 95.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span class="c1">Pick one scene and render it with at least 2048 samples per pixel. Show a good sampling rate image with clearly visible differences in sampling rate over various regions and pixels. Include both your sample rate image, which shows your how your adaptive sampling changes depending on which part of the image you are rendering, and your noise-free rendered result. Use 1 sample per light and at least 5 for max ray depth.</span></p><p class="c4"><span class="c0">High sampling rate = red</span></p><p class="c4"><span class="c0">Low sampling rate = blue</span></p><p class="c2"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 304.50px; height: 226.84px;"><img alt="" src="images/image25.png" style="width: 304.50px; height: 226.84px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.50px; height: 229.13px;"><img alt="" src="images/image30.png" style="width: 305.50px; height: 229.13px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 297.50px; height: 223.65px;"><img alt="" src="images/image32.png" style="width: 297.50px; height: 223.65px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 295.50px; height: 221.63px;"><img alt="" src="images/image14.png" style="width: 295.50px; height: 221.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c2"><span class="c0"></span></p><p class="c13"><span class="c14"><a class="c6" href="https://www.google.com/url?q=https://cal-cs184-student.github.io/sp22-project-webpages-Crazy010517/&amp;sa=D&amp;source=editors&amp;ust=1647993240707954&amp;usg=AOvVaw3TJypC0hE0-OeXplwUxeh7">https://cal-cs184-student.github.io/sp22-project-webpages-Crazy010517/</a></span></p></body></html>