<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">.lst-kix_ifh17cd9qgoo-6>li{counter-increment:lst-ctn-kix_ifh17cd9qgoo-6}.lst-kix_ifh17cd9qgoo-0>li{counter-increment:lst-ctn-kix_ifh17cd9qgoo-0}ol.lst-kix_ifh17cd9qgoo-4.start{counter-reset:lst-ctn-kix_ifh17cd9qgoo-4 0}ol.lst-kix_ifh17cd9qgoo-8.start{counter-reset:lst-ctn-kix_ifh17cd9qgoo-8 0}.lst-kix_ifh17cd9qgoo-1>li{counter-increment:lst-ctn-kix_ifh17cd9qgoo-1}.lst-kix_ifh17cd9qgoo-7>li{counter-increment:lst-ctn-kix_ifh17cd9qgoo-7}ol.lst-kix_ifh17cd9qgoo-1.start{counter-reset:lst-ctn-kix_ifh17cd9qgoo-1 0}ul.lst-kix_2po1en27efa9-2{list-style-type:none}ul.lst-kix_2po1en27efa9-3{list-style-type:none}ul.lst-kix_2po1en27efa9-4{list-style-type:none}ul.lst-kix_2po1en27efa9-5{list-style-type:none}ul.lst-kix_2po1en27efa9-6{list-style-type:none}ul.lst-kix_2po1en27efa9-7{list-style-type:none}.lst-kix_ifh17cd9qgoo-2>li{counter-increment:lst-ctn-kix_ifh17cd9qgoo-2}ol.lst-kix_ifh17cd9qgoo-5.start{counter-reset:lst-ctn-kix_ifh17cd9qgoo-5 0}ul.lst-kix_2po1en27efa9-8{list-style-type:none}.lst-kix_ifh17cd9qgoo-8>li{counter-increment:lst-ctn-kix_ifh17cd9qgoo-8}.lst-kix_ifh17cd9qgoo-5>li{counter-increment:lst-ctn-kix_ifh17cd9qgoo-5}ul.lst-kix_2po1en27efa9-0{list-style-type:none}ul.lst-kix_2po1en27efa9-1{list-style-type:none}ol.lst-kix_ifh17cd9qgoo-0{list-style-type:none}ol.lst-kix_ifh17cd9qgoo-1{list-style-type:none}.lst-kix_ifh17cd9qgoo-8>li:before{content:"" counter(lst-ctn-kix_ifh17cd9qgoo-8,lower-roman) ". "}ol.lst-kix_ifh17cd9qgoo-8{list-style-type:none}ol.lst-kix_ifh17cd9qgoo-6{list-style-type:none}ol.lst-kix_ifh17cd9qgoo-2.start{counter-reset:lst-ctn-kix_ifh17cd9qgoo-2 0}ol.lst-kix_ifh17cd9qgoo-7{list-style-type:none}ol.lst-kix_ifh17cd9qgoo-4{list-style-type:none}ol.lst-kix_ifh17cd9qgoo-5{list-style-type:none}ol.lst-kix_ifh17cd9qgoo-2{list-style-type:none}ol.lst-kix_ifh17cd9qgoo-3{list-style-type:none}ol.lst-kix_ifh17cd9qgoo-6.start{counter-reset:lst-ctn-kix_ifh17cd9qgoo-6 0}.lst-kix_ifh17cd9qgoo-2>li:before{content:"" counter(lst-ctn-kix_ifh17cd9qgoo-2,lower-roman) ". "}.lst-kix_ifh17cd9qgoo-3>li:before{content:"" counter(lst-ctn-kix_ifh17cd9qgoo-3,decimal) ". "}.lst-kix_2po1en27efa9-4>li:before{content:"-  "}.lst-kix_2po1en27efa9-6>li:before{content:"-  "}.lst-kix_ifh17cd9qgoo-0>li:before{content:"" counter(lst-ctn-kix_ifh17cd9qgoo-0,decimal) ". "}.lst-kix_ifh17cd9qgoo-1>li:before{content:"" counter(lst-ctn-kix_ifh17cd9qgoo-1,lower-latin) ". "}.lst-kix_ifh17cd9qgoo-4>li:before{content:"" counter(lst-ctn-kix_ifh17cd9qgoo-4,lower-latin) ". "}.lst-kix_ifh17cd9qgoo-5>li:before{content:"" counter(lst-ctn-kix_ifh17cd9qgoo-5,lower-roman) ". "}.lst-kix_2po1en27efa9-5>li:before{content:"-  "}.lst-kix_ifh17cd9qgoo-6>li:before{content:"" counter(lst-ctn-kix_ifh17cd9qgoo-6,decimal) ". "}.lst-kix_ifh17cd9qgoo-7>li:before{content:"" counter(lst-ctn-kix_ifh17cd9qgoo-7,lower-latin) ". "}.lst-kix_2po1en27efa9-2>li:before{content:"-  "}.lst-kix_ifh17cd9qgoo-3>li{counter-increment:lst-ctn-kix_ifh17cd9qgoo-3}.lst-kix_2po1en27efa9-3>li:before{content:"-  "}ol.lst-kix_ifh17cd9qgoo-3.start{counter-reset:lst-ctn-kix_ifh17cd9qgoo-3 0}.lst-kix_ifh17cd9qgoo-4>li{counter-increment:lst-ctn-kix_ifh17cd9qgoo-4}.lst-kix_2po1en27efa9-1>li:before{content:"-  "}.lst-kix_2po1en27efa9-0>li:before{content:"-  "}ol.lst-kix_ifh17cd9qgoo-0.start{counter-reset:lst-ctn-kix_ifh17cd9qgoo-0 0}ol.lst-kix_ifh17cd9qgoo-7.start{counter-reset:lst-ctn-kix_ifh17cd9qgoo-7 0}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_2po1en27efa9-8>li:before{content:"-  "}.lst-kix_2po1en27efa9-7>li:before{content:"-  "}ol{margin:0;padding:0}table td,table th{padding:0}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c0{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c3{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c9{padding:0;margin:0}.c7{margin-left:36pt;padding-left:0pt}.c5{font-style:italic}.c8{font-weight:700}.c6{vertical-align:sub}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c3"><p class="c4"><span class="c0">Task 1</span></p><p class="c4"><span class="c0">Walk through how you rasterize triangles in your own words.</span></p><p class="c4"><span class="c2">For rasterizing a triangle, you would loop through all of the pixels in the bounding rectangle of the triangle and using the technique from lecture, when we are given the three points of a triangle (P0, P1, P1) and a point C (x, y) to check:</span></p><p class="c1"><span class="c2"></span></p><ul class="c9 lst-kix_2po1en27efa9-0 start"><li class="c4 c7 li-bullet-0"><span class="c2">We first compute the perpendicular vector to the vector (P1 - P0) which is (-(y1 - y0), (x1 - x0)). </span></li><li class="c4 c7 li-bullet-0"><span class="c2">Then we compute the vector from P0 to the point C which is (x - x0, y - y0). </span></li><li class="c4 c7 li-bullet-0"><span class="c2">Then if we take the dot product of these two vectors, we can determine if the point lies above the line ( &gt; 0), on the line ( = 0 ), or under the line ( &lt; 0 ). </span></li></ul><p class="c1"><span class="c2"></span></p><p class="c4"><span>We repeat this process for the other two vectors of the triangle (P2 - P1), (P0 - P2). If all three dot products are </span><span class="c8">greater</span><span>&nbsp;than 0 or </span><span class="c8">equal</span><span>&nbsp;to 0, the point lies in the triangle (or on the edge of the triangle). If all three dot products are </span><span class="c8">less</span><span>&nbsp;than 0 or </span><span class="c8">equal</span><span class="c2">&nbsp;to 0, then the point also lies in the triangle (or on the edge of the triangle).</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c0">Explain how your algorithm is no worse than one that checks each sample within the bounding box of the triangle.</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c2">Instead of looping through every pixel in the image, we only loop through each pixel in the bounding box of the triangle.</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c0">Show a png screenshot of basic/test4.svg with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 465.44px; height: 363.02px;"><img alt="" src="images/image14.png" style="width: 465.44px; height: 363.02px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c0">Task 2</span></p><p class="c4"><span class="c0">Walk through your supersampling algorithm and data structures. Why is supersampling useful? What modifications did you make to the rasterization pipeline in the process? Explain how you used supersampling to antialias your triangles.</span></p><p class="c4"><span>Previously, we sampled each pixel just once in the center causing a lot of jaggies. Supersampling is useful because it smoothes out these jaggies (anti-aliasing). This is done by evenly sampling a pixel multiple times based on the </span><span class="c5">sample_rate</span><span>&nbsp;and then averaging these samples for the pixel color. For example, with a </span><span class="c5">sample_rate</span><span>&nbsp;of 4, we would &ldquo;split&rdquo; the pixel into 2x2 boxes and sample the center of each box and average the four sampled colors. For data structures, I used a 1D array to store (</span><span class="c5">width</span><span>&nbsp;* </span><span class="c5">height</span><span>&nbsp;* </span><span class="c5">sample_rate</span><span class="c2">) colors. Modifications I made to the pipeline included:</span></p><ol class="c9 lst-kix_ifh17cd9qgoo-0 start" start="1"><li class="c4 c7 li-bullet-0"><span>Changing </span><span class="c5">sample_buffer</span><span>&nbsp;to resize to (</span><span class="c5">width * height * sample_rate</span><span>) instead of just (</span><span class="c5">width * height</span><span class="c2">).</span></li><li class="c4 c7 li-bullet-0"><span>Changing </span><span class="c5">fill_pixel</span><span>&nbsp;to work with the bigger </span><span class="c5">sample_buffer</span><span>&nbsp;by filling up </span><span class="c5">sample_rate </span><span class="c2">colors for each pixel.</span></li><li class="c4 c7 li-bullet-0"><span>Changing </span><span class="c5">resolve_to_framebuffer </span><span>to average </span><span class="c5">sample_rate</span><span class="c2">&nbsp;colors for each pixel.</span></li></ol><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">Show png screenshots of basic/test4.svg with the default viewing parameters and sample rates 1, 4, and 16 to compare them side-by-side. Position the pixel inspector over an area that showcases the effect dramatically; for example, a very skinny triangle corner. Explain why these results are observed.</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 198.50px; height: 166.74px;"><img alt="" src="images/image3.png" style="width: 299.70px; height: 234.63px; margin-left: -101.20px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 197.50px; height: 165.45px;"><img alt="" src="images/image2.png" style="width: 296.25px; height: 227.79px; margin-left: -98.75px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 180.50px; height: 163.82px;"><img alt="" src="images/image11.png" style="width: 386.11px; height: 298.78px; margin-left: -205.61px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c2">As seen in these screenshots, the 1x sampling image shows an aliased triangle with jaggies and a break in the shape. In the 4x and 16x supersampling images, the jaggies are smoothed out and the shape is continuous. These results are observed because supersampling allows the color to be dependent on more than just one sample. For example, in the 1x sampling, the break is present because the center of a couple pixels happens to lie outside of the triangle. However, other parts of the pixels are inside the triangle and supersampling addresses this by looking at more than just the center of the pixel. </span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c0">Task 3</span></p><p class="c4"><span class="c0">Create an updated version of svg/transforms/robot.svg with cubeman doing something more interesting, like waving or running. Feel free to change his colors or proportions to suit your creativity. Save your svg file as my_robot.svg in your docs/ directory and show a png screenshot of your rendered drawing in your write-up. Explain what you were trying to do with cubeman in words.</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 416.09px; height: 324.73px;"><img alt="" src="images/image5.png" style="width: 416.09px; height: 324.73px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c2">I edited the robot.svg file to be a humanoid flexing his muscles. I increased the size of his upper arms, changed the color of 1 of the torso triangles, added rotations to the upper and lower arms, and changed the positions.</span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">Task 4</span></p><p class="c4"><span class="c0">Explain barycentric coordinates in your own words and use an image to aid you in your explanation. One idea is to use a svg file that plots a single triangle with one red, one green, and one blue vertex, which should produce a smoothly blended color triangle.</span></p><p class="c4"><span class="c2">Barycentric coordinates for triangles is a set of three numbers that sum up to 1 and each number represents how close a point is from the respective vertex of the triangle. Using these coordinates, we can compute how much each vertex affects the point&rsquo;s attributes (color in this case). For example, an alpha value of 1 would indicate the point is on the A vertex and the point&rsquo;s color would be solely dependent on A&rsquo;s color. That&rsquo;s why points closer to the A vertex appear more red. If alpha, beta, and gamma are all &#8531;, then the point&rsquo;s color would be equally dependent on the colors of all 3 vertices. If alpha is 0, then the point lies on the line between B and C, and the point&rsquo;s color would be dependent only on vertices B and C.</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 258.33px; height: 211.55px;"><img alt="" src="images/image4.png" style="width: 258.33px; height: 211.55px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c0">Show a png screenshot of svg/basic/test7.svg with default viewing parameters and sample rate 1. If you make any additional images with color gradients, include them.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 412.45px; height: 309.34px;"><img alt="" src="images/image9.png" style="width: 412.45px; height: 309.34px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c0">Task 5</span></p><p class="c4"><span class="c0">Explain pixel sampling in your own words and describe how you implemented it to perform texture mapping. Briefly discuss the two different pixel sampling methods, nearest and bilinear.</span></p><p class="c4"><span>Pixel sampling is determining the color at a specific pixel based on the applied texture on it. In task 5, I implemented pixel sampling by using barycentric coordinates to determine the proper UV coordinates of the texture at the pixel. Two different methods were then implemented to determine the color based on the UV coordinates (the (u, v) coordinate passed into these two functions were multiplied by (width - 1) and (height - 1) where width and height are dimensions of the mipmap). The first method is </span><span class="c8">nearest</span><span>&nbsp;neighbor which is where we round the UV coordinate to the nearest texture pixel location for the color. This is easy to implement but results in blockiness. The second method is </span><span class="c8">bilinear</span><span class="c2">&nbsp;interpolation which is where we find the 4 closest texture pixels and use 3 lerping functions to determine the color based on the UV coordinate&rsquo;s proximity to each of the 4 pixels. This method is a bit more complicated to implement but results in a much more smooth image. </span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">Check out the svg files in the svg/texmap/ directory. Use the pixel inspector to find a good example of where bilinear sampling clearly defeats nearest sampling. Show and compare four png screenshots using nearest sampling at 1 sample per pixel, nearest sampling at 16 samples per pixel, bilinear sampling at 1 sample per pixel, and bilinear sampling at 16 samples per pixel.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 226.94px; height: 181.20px;"><img alt="" src="images/image15.png" style="width: 226.94px; height: 181.20px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 220.66px; height: 175.20px;"><img alt="" src="images/image10.png" style="width: 220.66px; height: 175.20px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 243.50px; height: 185.10px;"><img alt="" src="images/image1.png" style="width: 243.50px; height: 185.10px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 230.50px; height: 183.42px;"><img alt="" src="images/image6.png" style="width: 230.50px; height: 183.42px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c2">In both 1x and 16x sampling, it is clear that bilinear produces an image that is more smooth than nearest pixel. However, nearest pixel 16x sampling is smoother than bilinear 1x sampling.</span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">Comment on the relative differences. Discuss when there will be a large difference between the two methods and why.</span></p><p class="c4"><span class="c2">In both 1x and 16x sampling, it is clear that bilinear produces an image that is more smooth than nearest pixel. However, nearest pixel 16x sampling is smoother than bilinear 1x sampling. A large difference between the two methods occurs when there are high frequency changes in nearby pixels. These high frequency changes are noticeable with the nearest pixel method (jaggies, blockiness) but the bilinear method is able to smooth out these high frequency changes by lerping colors from multiple neighboring pixels. </span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><hr style="page-break-before:always;display:none;"><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c8">Task 6</span></p><p class="c4"><span class="c0">Explain level sampling in your own words and describe how you implemented it for texture mapping.</span></p><p class="c4"><span>Textures at close range look good in full resolution but at longer distances, the textures can actually look better with lower resolution. With level sampling, we are able to choose different levels of resolutions for sampling pixels based on the distance. For the implementation, we first calculated the L value which represents the max distance change in the texture space corresponding to 1 pixel of change in the screen space (x + 1 or y + 1). We then take log</span><span class="c6">2</span><span>&nbsp;of L to determine the D level which represents what level of resolution and which mipmap to use. D = 0 is full resolution and every subsequent D value is half the resolution (Ex: </span><span class="c8">D = 0</span><span>: &nbsp;64x64, </span><span class="c8">D = 1</span><span>: 32x32, </span><span class="c8">D = 2</span><span class="c2">: 16x16, etc).</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">To choose the actual color, we implemented two methods.</span></p><p class="c4"><span class="c8">Method 1</span><span class="c2">: Nearest D level which is where we simply round D to the nearest integer and use the corresponding mipmap for choosing the color.</span></p><p class="c4"><span class="c8">Method 2</span><span class="c2">: The second method is Linear which is where we sample colors from both the mipmaps corresponding to floor(D) and ceil(D). Then we lerp between the two colors based on how close D is to floor(D) and ceil(D).</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">You can now adjust your sampling technique by selecting pixel sampling, level sampling, or the number of samples per pixel. Describe the tradeoffs between speed, memory usage, and antialiasing power between the three various techniques.</span></p><p class="c4"><span class="c8">Speed:</span><span>&nbsp;</span><span class="c8">Supersampling</span><span>&nbsp;is a great way to remove aliasing but it ends up being very inefficient as you must take multiple samples for each pixel. In pixel sampling, </span><span class="c8">nearest</span><span>&nbsp;is faster than </span><span class="c8">bilinear</span><span>&nbsp;because </span><span class="c8">bilinear</span><span>&nbsp;requires getting more texture colors and a few lerps. In level sampling, </span><span class="c8">zero</span><span>&nbsp;</span><span class="c8">level</span><span>&nbsp;and </span><span class="c8">nearest </span><span>are about the same in speed. However, </span><span class="c8">linear</span><span>&nbsp;is slower because it needs to calculate colors for two D levels and lerp them. </span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c8">Memory: Supersampling </span><span class="c2">requires more memory than 1 sample per pixel (in my implementation at least) because a bigger sample_buffer vector is required to store the colors. In pixel sampling, the memory required doesn&rsquo;t change significantly across different methods. In level sampling, &#8531; more memory is required to store the extra mipmaps. </span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c8">Anti-aliasing</span><span>: The more samples per pixel, the more anti-aliased the image is. In pixel sampling, </span><span class="c8">bilinear</span><span>&nbsp;is better at removing aliasing than </span><span class="c8">nearest</span><span>&nbsp;</span><span class="c8">pixel</span><span>. In level sampling, </span><span class="c8">linear</span><span>&nbsp;is better than </span><span class="c8">nearest level</span><span>&nbsp;which is better than </span><span class="c8">zero level</span><span class="c2">.</span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">Using a png file you find yourself, show us four versions of the image, using the combinations of L_ZERO and P_NEAREST, L_ZERO and P_LINEAR, L_NEAREST and P_NEAREST, as well as L_NEAREST and P_LINEAR.</span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 284.77px; height: 240.50px;"><img alt="" src="images/image8.png" style="width: 284.77px; height: 240.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 284.93px; height: 238.50px;"><img alt="" src="images/image13.png" style="width: 284.93px; height: 238.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 285.50px; height: 249.30px;"><img alt="" src="images/image7.png" style="width: 285.50px; height: 249.30px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 302.55px; height: 248.14px;"><img alt="" src="images/image12.png" style="width: 302.55px; height: 248.14px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p></body></html>