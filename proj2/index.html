<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-family:"Arial";font-style:normal}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c4{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-family:"Arial";font-style:normal}.c0{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c11{font-size:10.5pt;color:#0f68a0}.c5{color:#1c464a;font-size:10.5pt}.c10{color:#326d74;font-size:10.5pt}.c6{font-style:italic;font-weight:700}.c12{font-size:10.5pt}.c3{height:11pt}.c2{font-size:12pt}.c8{font-weight:700}.c9{font-size:13pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c0"><p class="c1"><span class="c4 c9">Overview</span></p><p class="c1"><span class="c7 c2">In this project, I implemented de Casteljau&rsquo;s algorithm to evaluate Bezier curves and extended the concept to Bezier surfaces. I also implemented a function for calculating area weighted vertex normals which are used for smoothly shading meshes. Finally, I was able to work with and gain a deeper understanding of the HalfEdge data structure by implementing critical mesh editing functions such as EdgeFlip and EdgeSplit which were used in the final part, loop subdivision, to upscale meshes to a higher resolution. I was able to avoid bugs for most of the parts by drawing out and labeling edges, vertices, faces, etc before writing the code and being extremely careful with the pointer assignments. However, I ran into some problems in the final part which are described in more details below.</span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1 c3"><span class="c4 c9"></span></p><p class="c1"><span class="c8 c9">Part 1</span></p><p class="c1"><span class="c4 c2">Briefly explain de Casteljau&#39;s algorithm and how you implemented it in order to evaluate Bezier curves.</span></p><p class="c1"><span class="c2">De Casteljau&rsquo;s algorithm allows us to compute a point on the bezier curve given a list of </span><span class="c6 c2">n</span><span class="c2">&nbsp;control points and a scalar </span><span class="c6 c2">t</span><span class="c2">. At each recursive step, we compute the </span><span class="c6 c2">n - 1</span><span class="c7 c2">&nbsp;intermediate points (t * points[n] + (1 - t) * points[n + 1]). The last recursive step will give us the point on the curve. For part 1, we simply had to implement evaluateStep which computes 1 recursive step. We looped through the given control points and t and computed the intermediate points for the step as described above.</span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span class="c4 c2">Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your choosing. Use this Bezier curve for your screenshots below.</span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span class="c4 c2">Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press E to step through. Toggle C to show the completed Bezier curve as well.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.50px; height: 205.83px;"><img alt="" src="images/image31.png" style="width: 307.50px; height: 205.83px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 281.09px; height: 200.65px;"><img alt="" src="images/image3.png" style="width: 281.09px; height: 200.65px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 290.50px; height: 201.30px;"><img alt="" src="images/image19.png" style="width: 290.50px; height: 201.30px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 290.50px; height: 199.52px;"><img alt="" src="images/image1.png" style="width: 290.50px; height: 199.52px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 274.50px; height: 193.50px;"><img alt="" src="images/image30.png" style="width: 274.50px; height: 193.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span class="c4 c2">Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter tt via mouse scrolling.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 435.50px; height: 268.00px;"><img alt="" src="images/image22.png" style="width: 435.50px; height: 268.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1 c3"><span class="c7 c2"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1"><span class="c4 c2">Part 2</span></p><p class="c1"><span class="c4 c2">Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.</span></p><p class="c1"><span class="c2">We can extend De Casteljau&rsquo;s algorithm to Bezier surfaces by having a 2D array of control points. Each row in the array controls a 1D bezier curve controlled by the scalar </span><span class="c6 c2">u</span><span class="c2">. Each row is evaluated to output a new control point and these control points are then evaluated with the scalar </span><span class="c6 c2">v</span><span class="c7 c2">&nbsp;for the final point on the surface. </span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1"><span class="c2">We first implemented </span><span class="c5">BezierPatch</span><span class="c11">::evaluateStep()</span><span class="c8 c11">&nbsp;</span><span class="c2">which was basically the same as </span><span class="c5">BezierCurve</span><span class="c11">::evaluateStep() </span><span class="c2">except with Vector3D instead of Vector2D. We then implemented evaluate1D which repeatedly calls evaluateStep until we end up with the final point. Lastly, we implemented </span><span class="c5">BezierPatch::</span><span class="c11">evaluate() </span><span class="c2">which called evaluate1D on every row in the 2D array with scalar </span><span class="c2 c6">u</span><span class="c2">, pushed the result to a new array, and finally called evaluate 1D on the new array with scalar </span><span class="c6 c2">v</span><span class="c2">&nbsp;to get the point on the surface. </span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span class="c4 c2">Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.</span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 434.67px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 434.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span class="c2 c8">Part 3</span></p><p class="c1"><span class="c4 c2">Briefly explain how you implemented the area-weighted vertex normals.</span></p><p class="c1"><span class="c2">Starting from the vertex&rsquo;s HalfEdge, I traversed through the HalfEdges (skipping over &ldquo;boundary&rdquo; ones) until I returned to the vertex&rsquo;s HalfEdge (</span><span class="c12">h = h-&gt;</span><span class="c10">twin</span><span class="c12">()-&gt;</span><span class="c10">next</span><span class="c12">());</span><span class="c2">&nbsp;. At each HalfEdge, I added the HalfEdge&rsquo;s face&rsquo;s normal to a running Vector3D sum. At the end of the function, I returned the normalized Vector3D sum. Because </span><span class="c10">h-&gt;face()-&gt;normal() </span><span class="c2">is implemented with cross product, the normal returned already takes into account the weighted area. </span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1"><span class="c4 c2">Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use Q to toggle default flat shading and Phong shading.</span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 270.71px; height: 179.77px;"><img alt="" src="images/image20.png" style="width: 270.71px; height: 179.77px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 280.85px; height: 180.77px;"><img alt="" src="images/image9.png" style="width: 280.85px; height: 180.77px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c2 c4"></span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span class="c4 c2">Part 4</span></p><p class="c1"><span class="c4 c2">Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.</span></p><p class="c1"><span class="c7 c2">For the implementation, the first thing I did was pull up the slide from lecture (see below) to easily visualize the flip. I wanted to make sure my code was super clean for this implementation so I can avoid silly mistakes and to make it easier to debug if necessary. To this end, I first created variables for every vertex, edge, halfedge, and face (returned if either face was on the boundary). Then I assigned the halfedge for each vertex, face, and edge and finally, the neighbors for each halfedge. Fortunately, because I double checked every assignment after writing it, the implementation worked on the first try.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 397.77px; height: 191.23px;"><img alt="" src="images/image10.png" style="width: 397.77px; height: 191.23px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span class="c4 c2">Show screenshots of the teapot before and after some edge flips.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 289.50px; height: 188.07px;"><img alt="" src="images/image34.png" style="width: 289.50px; height: 188.07px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 313.09px; height: 186.29px;"><img alt="" src="images/image23.png" style="width: 313.09px; height: 186.29px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1"><span class="c4 c2">Write about your eventful debugging journey, if you have experienced one.</span></p><p class="c1"><span class="c7 c2">I was able to completely avoid debugging luckily :)</span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span class="c4 c2">Part 5</span></p><p class="c1"><span class="c4 c2">Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.</span></p><p class="c1"><span class="c7 c2">Following the recommendation from the project specs, I decided to draw out the triangles before and after the split and label all of the components. This made it much easier to visualize what is connected to what and reduced the chance of silly mistakes. For the implementation, I created variables for all of the existing components and created new ones according to my drawings. Then I assigned the HalfEdge to the vertices, the edges, and the faces. Lastly, I assigned the neighbors for all of the HalfEdges.</span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 244.50px; height: 164.42px;"><img alt="" src="images/image29.jpg" style="width: 244.50px; height: 164.42px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 223.50px; height: 162.64px;"><img alt="" src="images/image28.jpg" style="width: 223.50px; height: 162.64px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c4 c2">Show screenshots of a mesh before and after some edge splits.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 166.23px; height: 191.55px;"><img alt="" src="images/image8.png" style="width: 166.23px; height: 191.55px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 165.50px; height: 193.40px;"><img alt="" src="images/image6.png" style="width: 165.50px; height: 193.40px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 170.84px; height: 197.70px;"><img alt="" src="images/image25.png" style="width: 170.84px; height: 197.70px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 171.50px; height: 193.67px;"><img alt="" src="images/image24.png" style="width: 171.50px; height: 193.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c4 c2">Show screenshots of a mesh before and after a combination of both edge splits and edge flips.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 193.50px; height: 208.72px;"><img alt="" src="images/image2.png" style="width: 193.50px; height: 208.72px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 186.50px; height: 205.86px;"><img alt="" src="images/image32.png" style="width: 186.50px; height: 205.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 199.50px; height: 200.29px;"><img alt="" src="images/image11.png" style="width: 199.50px; height: 200.29px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span class="c4 c2">Write about your eventful debugging journey, if you have experienced one.</span></p><p class="c1"><span class="c7 c2">Once again, I was able to avoid debugging by carefully checking each line of code (especially the pointer assignments) after writing it.</span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1"><span class="c2 c8">Part 6</span></p><p class="c1"><span class="c4 c2">Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used.</span></p><p class="c1"><span class="c7 c2">For my implementation, I followed the steps described under the upsample function, referring to my Part 5 drawings for a visualization of the labels. Unfortunately, the implementation did not work right away. The mesh disappeared on the first subdivision and the program froze when I tried a second subdivision. There were multiple bugs at play here with the first being multiplying an integer by a double resulting in the product becoming 0. I was able to discover this bug by printing out the positions of vertices. The second bug was due to an infinite loop while splitting. I was able to find an answer on Piazza which suggested that I use a counter to loop through the edges to avoid continuously looping over new edges created by splitting. </span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span class="c4 c2">Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 180.96px; height: 179.03px;"><img alt="" src="images/image15.png" style="width: 180.96px; height: 179.03px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 179.44px; height: 183.03px;"><img alt="" src="images/image14.png" style="width: 179.44px; height: 183.03px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 184.03px; height: 184.03px;"><img alt="" src="images/image21.png" style="width: 184.03px; height: 184.03px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 185.03px; height: 139.66px;"><img alt="" src="images/image27.png" style="width: 185.03px; height: 139.66px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 206.50px; height: 138.01px;"><img alt="" src="images/image17.png" style="width: 206.50px; height: 138.01px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 184.32px; height: 141.18px;"><img alt="" src="images/image33.png" style="width: 184.32px; height: 141.18px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c7 c2">When using loop subdivision on a mesh, the resolution of the mesh is indeed increased. As you can see in the bean.dae screenshots, the border of the shape becomes noticeably smoother as expected. However, the overall shape of the mesh is not necessarily preserved as seen in the torus screenshots. But it&rsquo;s also interesting to consider that the original &ldquo;hexagonal&rdquo; torus is just a low resolution torus so loop subdivision is working properly by rounding out the sharp edges to create a high resolution torus although it is technically changing the overall shape.</span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1"><span class="c2 c7">If it is desired to preserve these sharp edges though, we can indeed pre-split the sharp edges before loop subdivision. </span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 239.50px; height: 262.00px;"><img alt="" src="images/image26.png" style="width: 239.50px; height: 262.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c2">&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 293.05px; height: 265.97px;"><img alt="" src="images/image4.png" style="width: 293.05px; height: 265.97px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1"><span class="c7 c2">As shown in the screenshots, by pre-splitting one of the torus&rsquo;s edges several times, the sharp edge is preserved after loop subdivision. This is because during loop subdivision, the positions of the vertices are calculated using the positions of its neighboring vertices. So if the neighboring vertices are all flat relative to a vertex, then that vertex&rsquo;s new position will stay &ldquo;flat&rdquo; resulting in the sharp edge being preserved. </span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span class="c4 c2">Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. </span></p><p class="c1"><span class="c4 c2">Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects.</span></p><p class="c1 c3"><span class="c4 c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 194.50px; height: 164.04px;"><img alt="" src="images/image7.png" style="width: 194.50px; height: 164.04px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 184.50px; height: 167.95px;"><img alt="" src="images/image13.png" style="width: 184.50px; height: 167.95px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 174.23px; height: 165.18px;"><img alt="" src="images/image35.png" style="width: 174.23px; height: 165.18px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 195.21px; height: 170.50px;"><img alt="" src="images/image16.png" style="width: 195.21px; height: 170.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 181.50px; height: 171.19px;"><img alt="" src="images/image12.png" style="width: 181.50px; height: 171.19px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 172.50px; height: 172.50px;"><img alt="" src="images/image18.png" style="width: 172.50px; height: 172.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c7 c2">As seen in these screenshots, the original cube.dae mesh becomes asymmetric after subdivisions. This effect shows the importance of having symmetric topography before subdivisioning. Because each face only has two triangles, they are asymmetric with its adjacent faces and results in an asymmetric shape after subdivisioning.</span></p><p class="c1 c3"><span class="c7 c2"></span></p><p class="c1"><span class="c7 c2">However, if we were to pre-split each face so that they each consist of four triangles, then the faces become symmetric with each other which results in a symmetric shape after subdivisioning.</span></p><p class="c1 c3"><span class="c4 c2"></span></p></body></html>